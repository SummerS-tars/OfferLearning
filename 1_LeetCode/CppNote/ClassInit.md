# C++ 类的初始化与构造（重点在前，补充在后）

> 专注“如何正确初始化类”和相关语法/规则；便于速查与面试复盘。

## 一页速览（最重要）

- 构造与初始化的基本方式
    - 默认构造：无参构造；可显式 `= default` 引入默认版本
    - 直接/复制初始化：`T a(x);` / `T a = x;`
    - 列表/统一初始化（brace）：`T a{args...};`，可避免窄化转换
    - 成员初始化列表：`T::T() : m(x), n(y) {}`（优先于构造体内赋值）
    - 类内成员初始值：`int m = 42;`，作为“默认值”，被构造器覆盖时以构造器为准
    - 委托构造：一个构造函数调用同类的另一个构造 `T(): T(42) {}`
- 特殊成员函数（显式默认/禁用）
    - `= default`：请求编译器生成默认实现（构造/析构/拷贝/移动）
    - `= delete`：禁用对应函数（常用于禁用拷贝/默认构造）
    - Rule of Zero/Three/Five：资源管理优先“零”，否则至少成套地实现拷贝/析构/移动
- 初始化顺序与约束
    - 顺序：先基类，后成员（按声明顺序），最后构造体主体；与初始化列表的书写顺序无关
    - const/引用成员必须在“成员初始化列表”中初始化；不能在构造体主体赋值
    - 静态成员在类外定义与初始化（非整型常量需类外定义）
- 语义修饰（常用）
    - `explicit`：避免隐式转换的单参构造
    - `constexpr`：常量表达式可用的构造/方法/对象
    - `noexcept`：标注不抛异常（影响优化与异常安全）
    - `[[nodiscard]]`：提示返回值不应被忽略
- 资源管理与所有权
    - 优先使用智能指针（`std::unique_ptr`/`std::shared_ptr`）与 RAII，减少手写 `new/delete`

---

## 初始化方式与适用场景（展开）

- 默认构造
    - 当类没有显式声明构造时，编译器可能生成隐式默认构造；若已声明其他构造，隐式默认构造被抑制，可用 `T() = default;` 显式引入
    - 适合“值成员都有默认构造”的类，如 `std::stack<int> m;` 不需要 `new`

- 直接/复制初始化
    - 语义：`T a(x);` 直接调用构造；`T a = x;` 可能调用拷贝/移动（对现代编译器会省略）
    - 选择：更偏向 `T a(x);`，避免赋值语义混淆

- 列表/统一初始化（brace）
    - `T a{args...};`；能避免窄化转换；对聚合类型可进行“聚合初始化”
    - 与 `()` 的差异：`{}` 可能更严格；对 STL 容器常用 `{}` 初始化列表

- 成员初始化列表 vs 构造体内赋值
    - 成员初始化列表在对象构造时一次到位；效率更高
    - 构造体主体内赋值是“先默认构造，再赋值”，对无默认构造/const/ref 成员不可行
    - 经验法则：尽量用成员初始化列表给成员设值

- 类内成员初始值（in-class initializer）
    - 为成员提供“默认值”；若构造函数也对该成员赋值，则以构造函数为准
    - 简化多个构造函数中重复初始化的代码

- 委托构造
    - 一个构造调用同类另一个构造以复用逻辑：`T(): T(42) { /*额外动作*/ }`
    - 注意顺序：被委托的构造先运行；避免循环委托

---

## 特殊成员函数与所有权（展开）

- `= default` 与 `= delete`
    - default：保留“trivial/noexcept/constexpr”等性质；语义明确
    - delete：在接口层面禁用（如禁用拷贝，只允许移动）

- Rule of Zero/Three/Five
    - Zero：若只用标准资源管理（智能指针/容器），通常不需要自定义析构/拷贝/移动
    - Three：若定义了析构，通常也需要定义拷贝构造与拷贝赋值
    - Five：同时考虑移动构造与移动赋值

- 拷贝与移动
    - 拷贝：深/浅拷贝的选择基于资源语义；容器与智能指针已封装好
    - 移动：转移所有权避免不必要拷贝；标注 `noexcept` 可提升容器优化机会

- RAII 与智能指针
    - unique_ptr：独占所有权；自定义删除器支持资源释放策略
    - shared_ptr：共享所有权；注意循环引用（配合 weak_ptr）

---

## 初始化顺序与约束（细节）

- 基类 -> 成员（声明顺序） -> 构造体主体
    - 无论初始化列表如何书写，成员的真实初始化顺序按“成员声明顺序”进行；不要依赖列表书写顺序来满足依赖关系

- const/引用成员
    - 必须在初始化列表中初始化；不可在构造体主体赋值

- 静态成员
    - 静态数据成员在类外定义与初始化（除 `inline` 或整型常量特殊规则）

- 异常安全
    - 构造抛异常时，已完成构造的子对象会被正确析构；保持成员的强异常安全性（如使用强异常安全容器/智能指针）

---

## 语义修饰与接口设计（补充）

- explicit
    - 用于单参构造/可转换构造，禁止隐式转换以防意外

- constexpr
    - 允许在编译期常量上下文使用；要求所有成员初始化也是常量表达式

- noexcept
    - 声明不抛异常；影响标准容器对“移动”的选择（更倾向使用不抛异常的移动）

- [[nodiscard]]
    - 提示返回值应被使用；增强接口的正确性

---

## 常见误区与速修建议（补充）

- 在值成员上使用 `new`
    - 误区：`this->member = new Type()`；值成员无需也不能 `new`
    - 修正：值成员默认构造或在初始化列表中赋值；若需动态分配，使用智能指针成员

- 忘记成员初始化顺序
    - 误区：依赖初始化列表的书写顺序来安排依赖
    - 修正：按“成员声明顺序”安排依赖或重构为独立函数

- 构造体主体内为 const/ref 成员赋值
    - 误区：在构造函数体内为 const/ref 成员赋值
    - 修正：一律放到成员初始化列表

- 滥用隐式转换
    - 误区：单参构造成隐式转换造成意外匹配
    - 修正：加 `explicit`，或提供工厂函数明确转换

---

## 复盘要点（面试/实践）

- 能解释“= default / = delete”和 Rule of Zero/Three/Five
- 能说明“成员初始化列表”的必要性及与“构造体内赋值”的差异
- 能说清“初始化顺序”与“const/ref 必须在初始化列表”
- 能合理使用 `explicit/constexpr/noexcept/[[nodiscard]]`
- 能用智能指针与 RAII 设计资源类，避免手写 `new/delete`

