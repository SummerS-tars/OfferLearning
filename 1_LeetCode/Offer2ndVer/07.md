# 07

LCR 124. 推理二叉树

## 题目描述

根据二叉树的先序遍历结果和中序遍历结果，重建二叉树并返回其根节点。  
限定：preorder 和 inorder 均无重复元素。  

数据规模：  

1 <= preorder.length <= 3000  
-3000 <= preorder[i], inorder[i] <= 3000  
保证数据合法性  

## 思路

先序遍历中有A  
中序遍历中，A左侧的是左子树，右侧的是右子树  

递归  
如何分解问题？  
不断将中序遍历划分为左右子树，然后在先序遍历中找到对应的左右子树节点即可  
递归边界：子树节点数量为0（中序遍历的左右边界相等）  

细节问题：  
如何在先序遍历中找到当前子树的根节点？  

首先第一个肯定是根节点  

3 9 20 15 7  
9 3 15 20 7  

### 实现一

没看懂  

```cpp
class Solution {
public:
    TreeNode* deduceTree(vector<int>& preorder, vector<int>& inorder) {
        if (preorder.empty() || inorder.empty()) return nullptr;
        unordered_map<int, int> index;
        for (int i = 0; i < (int)inorder.size(); ++i) index[inorder[i]] = i;
        return build(preorder, 0, (int)preorder.size() - 1,
                     inorder, 0, (int)inorder.size() - 1,
                     index);
    }

private:
    // 基于区间的递归：preorder[preL..preR] 与 inorder[inL..inR]
    TreeNode* build(const vector<int>& preorder, int preL, int preR,
                    const vector<int>& inorder, int inL, int inR,
                    const unordered_map<int,int>& index) {
        if (preL > preR || inL > inR) return nullptr; // 空子树
        int rootVal = preorder[preL];
        TreeNode* root = new TreeNode(rootVal);
        int k = index.at(rootVal);           // 根在中序中的位置
        int leftSize = k - inL;              // 左子树大小
        // 左：preL+1 .. preL+leftSize， 中：inL .. k-1
        root->left = build(preorder, preL + 1, preL + leftSize,
                           inorder, inL, k - 1, index);
        // 右：preL+leftSize+1 .. preR， 中：k+1 .. inR
        root->right = build(preorder, preL + leftSize + 1, preR,
                            inorder, k + 1, inR, index);
        return root;
    }
};
```

### 实现二

解析：  
总之就是不断将中序遍历结果划分为左右子树  
然后作为一个整体（子树）继续进行划分  
最后从叶子节点往上构建整棵树  

```cpp
class Solution {
public:
    TreeNode* deduceTree(vector<int>& preorder, vector<int>& inorder) {
        int preIndex = 0;
        TreeNode* root = recursionBuildTree(preorder, inorder, preIndex, 0, inorder.size() - 1);
        return root;
    }

private:
    /**
    以preorder为主线，不断将inorder细分为左右子树与根
    preIndex: 当前遍历preorder的索引值
    return: 子树的根节点
    */
    TreeNode* recursionBuildTree(const vector<int>& preorder,
                                const vector<int>& inorder, 
                                int& preIndex,
                                int inL, int inR) {
        if(inL > inR) return nullptr; // 空节点
        int rootVal = preorder[preIndex++];
        TreeNode* root = new TreeNode(rootVal);
        
        auto it = find(inorder.begin() + inL, inorder.begin() + inR + 1, rootVal);
        int rootInorderIndex = it - inorder.begin(); // 当前子树的根在inorder中的索引值
        root->left = recursionBuildTree(preorder, inorder, preIndex, inL, rootInorderIndex - 1);
        root->right = recursionBuildTree(preorder,inorder, preIndex, rootInorderIndex + 1, inR);
        return root;
    }
};
```

优化方法：  

- 减少参数：将preoder和inorder改为成员变量  
- 提前构建哈希表，减少find的时间开销  
