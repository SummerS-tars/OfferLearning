# 11

LCR 128. 库存管理 I

## 题目描述

stock: 数组，记录库存表  

stock[i]: 商品id（可能重复）  

原库存按id升序排列  

经过操作：将某些前面的商品原序移至最后（保持顺序）  
可能是为了方便取货吧，但不用管  

需求：找到编号最小的元素  

数据规模：  

1 <= stock.length <= 5000
-5000 <= stock[i] <= 5000  

## 思路

最暴力：  
从前往后，维护最小值  

为了优化，我们从题目中试图找隐藏信息  
发现一个：最后的总是小于最前面的元素  
这种亚单调性可能可以用二分查找

set左边为left，右边为right
我们不妨假设一下  
这中间的值必然要么大于left，要么小于right  

我们取mid = (left+right)/2
如果大于left说明最小值肯定在右边  
如果小于right说明最小值肯定在左边  
如此一定可以找到最小值  

```cpp
class Solution {
public:
    int inventoryManagement(vector<int>& stock) {
        int leftVal = *stock.begin();
        int rightVal = *(stock.end()-1);
        if(leftVal < rightVal) return leftVal; // 处理完全没有逆序的情况

        int l = 0, r = static_cast<int>(stock.size()) - 1;
        while (l < r) {
            int mid = l + ((r - l) >> 1);
            if (stock[mid] > stock[r]) {
                // 最小值在右半部分
                l = mid + 1;
            } else if (stock[mid] < stock[r]) {
                // 最小值在左半部分（含 mid）
                r = mid;
            } else {
                // 相等时无法判定区间，安全缩小右边界以处理重复
                r--;
            }
        }

        return stock[l];
    }
};
```

有哪些极端情况？  

- 全部相等  
- 很多相等的（例如左边到中间的值都等于左边界情况A，以及相反的情况B）  
    这个容易导致错误的边界收缩，A的最小值在右边，B的最小值在左边  
    而二分法无法知道在哪一边，只能逐步缩小范围  
- 完全没有逆序（已经排序好了）  
