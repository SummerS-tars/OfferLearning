# 04

LCR 121. 寻找目标值 - 二维数组

## 题目描述

plants: m * n 二维数组  

值：表示植物高度  

限制：行数或者列数更高的，高度一定更高  

要求：判断plants中是否存在某个值等于target  

范围：  

0 <= m, n <= 1000  

## 思路

### 解法一

暴力做法  
每行先看target是否在范围内（行首行尾比较）  
在范围内再二分查找  

```cpp
class Solution {
public:
    bool findTargetIn2DPlants(vector<vector<int>>& plants, int target) {
        for (const auto& plantRow : plants) {
            if (plantRow.empty()) continue; // 跳过空行，避免越界
            if (isTargetPossibleRange(plantRow, target) && isTargetExist(plantRow, target))
                return true;
        }
        return false;
    }

private: 
    bool isTargetPossibleRange(const vector<int>& plantRow, int target) {
        // 行首 <= target <= 行尾
        return plantRow.front() <= target && target <= plantRow.back();
    }

    bool isTargetExist(const vector<int>& plantRow, int target) {
        int l = 0, r = static_cast<int>(plantRow.size()) - 1;
        while (l <= r) {
            int mid = l + ((r - l) >> 1); // 正确的二分中点
            if (plantRow[mid] < target) l = mid + 1;
            else if (plantRow[mid] > target) r = mid - 1;
            else return true;
        }
        return false;
    }
};
```

时间复杂度：  
O(n) * O(log m) = O(n log m)  
空间复杂度：O(1)  

## 解法二

将右上角的元素看作根  
则转化为二叉搜索树的查找问题  

如何前往左子树？  
行数 --  
如何前往右子树？  
列数 ++  

```cpp
class Solution {
public:
    bool findTargetIn2DPlants(vector<vector<int>>& plants, int target) {
        if (plants.empty()) return false;           // 全为空（m = 0）
        if (plants[0].empty()) return false;        // 列为空（n = 0）
        int row = 0;
        int col = static_cast<int>(plants[0].size()) - 1;
        while (row < static_cast<int>(plants.size()) && col >= 0) {
            int val = plants[row][col];
            if (val == target) return true;
            else if (val > target) col--;
            else row++;
        }
        return false;
    }
};
```
