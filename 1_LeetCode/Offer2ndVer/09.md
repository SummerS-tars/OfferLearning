# 09

LCR 125. 图书整理 II

## 题目描述

实体：  

读者  
两个书车：包含书  
书从下往上叠放（每次只能取顶部）  

需要实现两种操作：  

push(bookID): 将借阅的书归还  

pop(): 从图书馆借书  

限制：  
需要保持图书的顺序  
图书管理员每次取书为**最早**归还的书籍  
返回每次读者借出的书id  
如果没书，返回 -1  

## 思路

简单来说就是两个栈模拟一个队列  

### 实现一

```cpp
class CQueue {
public:
    CQueue() {
        this->bookCar = stack<int>();
        this->tmpBookCar = stack<int>();
    }
    
    void appendTail(int value) {
        while(!bookCar.empty()) {
            tmpBookCar.push(bookCar.top());// 先全部转移至缓冲车（反序）
            bookCar.pop();
        }
        bookCar.push(value); // 压入新存入的书
        while(!tmpBookCar.empty()) {
            bookCar.push(tmpBookCar.top());
            tmpBookCar.pop();
        }
    }
    
    int deleteHead() {
        if(bookCar.empty()) return -1;
        int bookID = bookCar.top();
        bookCar.pop();
        return bookID;
    }

private:
    stack<int> bookCar, tmpBookCar;
};
```

### 实现二

这是更标准的双栈模拟队列写法  
相较于实现一，采用了懒加载的思想  
只有需要出队时，再把入栈的元素倒到出栈  
这样每个元素最多只会被倒一次，均摊时间复杂度更优  

```cpp
class CQueue {
public:
    CQueue() = default; // 栈成员默认构造即可，无需 new
    
    void appendTail(int value) {
        // 入队：直接压入入栈（保持 O(1)）
        bookCar.push(value);
    }
    
    int deleteHead() {
        // 出队：若出栈为空，则把入栈元素全部倒到出栈（反序），仅在需要时倒一次
        if (tmpBookCar.empty()) {
            while (!bookCar.empty()) {
                tmpBookCar.push(bookCar.top());
                bookCar.pop();
            }
        }
        if (tmpBookCar.empty()) return -1; // 队列为空
        int bookID = tmpBookCar.top();
        tmpBookCar.pop();
        return bookID;
    }

private:
    stack<int> bookCar, tmpBookCar;
};
```
