# 19

LCR 137. 模糊搜索验证

## 题目描述

支持模糊搜索功能  

可能的通配符：  

1. `.` 匹配任意单个字符  
2. `*` 匹配0或多个前面的那一个元素

`input`: 用户输入内容  
`article`： 文章内容  

返回：  
`article` 中是否能被 `input` 匹配  
注意是`article` 整体，不能是其子串被匹配  

限制：  
1 <= article.length <= 20  
1 <= input.length <= 20  

article 仅包含小写字母  
input 仅包含小写字母，`.`，`*`  
保证每次出现 `*` 时，前面都匹配到有效的字符  

## 思路

子思路一：  
倒过来匹配（使用栈）  
可以处理多字符通配符后置的情况  
例如 `a*b` 可以匹配 `aaab`  
例如 `a.*b` 可以匹配 `axyzb`  
？但这样前面的又不行了  

子思路二：  
使用递归处理  
遇到通配符就分支处理  
（例如 `.` 就直接跳过一个字符）  
（例如 `*` 就跳过一个匹配到的字符，再在字串中找尾部是否能匹配input字符，此时前面的部分可以逐个尝试，直到找到可以开始匹配的再开始尝试）  

递归思路细化：  
边界处理：  

1. input和article都为空，返回true  
2. article为空，input不为空，返回false
3. input为空，article不为空，返回false  
    但是这个情况要注意，如果上一次处理的是 `*`，可能是可以匹配的  
4. input和article都不为空，继续处理

递归处理：  

1. 先判断是否是通配符（此处需要  
    1. 无 `*` 情况  
        1. 正常匹配
        2. 有`.`则直接判断匹配成功，进入下一步
    2. 有 `*` 情况  
        总体思路：对每个可能的匹配长度进行尝试，全都失败后才返回false  
        先尝试0个字符匹配，再尝试1个字符匹配，直到尝试完所有可能的匹配长度  
        1. 无`.`情况，尝试先匹配1个字符，进入下一步
        2. 有`.`情况，直接跳过一个字符，进入下一步
