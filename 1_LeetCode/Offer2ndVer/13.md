# 14

LCR 130. 衣橱整理

## 题目描述

grid: m * n 二维数组，m行n列  

grid\[i][j]: 一个需要整理的格子  

cnt: int参数

从grid\[0][0]开始整理  
方式：逐行逐列  

整理规则：  
row + 1 or col + 1  
不能越界  
不需要整理 digit(row) + digit(col) > cnt的格子  
digit(x) 表示数字 x 的各数位之和  

限制：  
1 <= n, m <= 100  
0 <= cnt <= 20  

求：  
总共需要整理多少格子  

cnt 相当于一个线（从矩阵左下到右上）  
其左上部分的格子是需要整理的  

## 思路

需要处理的问题：  
如何移动？  
如何处理边界？  

0 1  2  3  4  5  6  7  8  9  1  2
1
2
3
4
5
...                          9
9 10 11 12 13 14 15 16 17 18 10
1 2  3  4  5  6  7  8  9  10 2
2 
3
4
5
6
7
8
9 
10 11 12 13 14 15 16 17 18 19 11
2
3
4
...

10 11 12 13 14 15  
1  2  3  4  5  6

总结：  
行列的实际作用大小  
digit(row) -> row / 100 + (raw % 100) / 10 + raw % 10  

规律：  
digit(row) + digit(col) 会在矩阵中形成几条斜线  

example:  
4 * 8 , cnt = 5  

0 1 2 3 4 5 6 7
1       5 6 7 8
2     5 6 7 8
3   5 6 7 8
4 5 6 7 8

cnt 8

如果m或n较大，可能会有几个可行解区域  
但是此时可能需要分情况：  
可能会相连，也可能不相连  

## 实现思路

最暴力：  
总之dfs遍历每一个可行解  

优化：  
划分线的边缘一定出现在 9， 19， 29... 之类的地方  
或者在边界处  

规律：  
行和列的digit呈现为不断增加然后忽然减少又重新上升的趋势  
具体规律是  
跨越边界之后会-8  
